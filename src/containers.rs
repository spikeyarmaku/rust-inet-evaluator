use std::ops::Index;
use std::ops::IndexMut;

pub struct Stack<T>(Vec<T>);

// The heap contains the agents. Freeing an agent leaves an empty space that can
// be filled later. Option<T> is used so empty spaces can be marked
pub struct Heap<T> {
    empty_count: usize,
    data: Vec<Option<T>>,
}

impl<T> Heap<T> {
    pub fn new() -> Self {
        Heap {
            empty_count: 0,
            data: Vec::new(),
        }
    }

    // Return the number of occupied entries (only used for debugging)
    pub fn len(&self) -> usize {
        self.data.len() - self.empty_count
    }

    // Return the actual size of the underlying vec (only used for debugging)
    pub fn full_len(&self) -> usize {
        self.data.len()
    }

    // Find the first empty position (value = None), put the element there, and
    // return the position. If no empty positions found, append it to the end of
    // the list
    pub fn push(&mut self, item: T) -> usize {
        match self.data.iter().position(|r| r.is_none()) {
            None => {
                self.data.push(Some(item));
                self.data.len() - 1
            }
            Some(i) => {
                self.data[i] = Some(item);
                self.empty_count -= 1;
                i
            }
        }
    }

    // Mark the `index`th entry as empty
    pub fn remove(&mut self, index: usize) {
        if self.data[index].is_some() {
            self.data[index] = None;
            self.empty_count += 1;
        }
    }
}

impl<T> Index<usize> for Heap<T> {
    type Output = T;

    fn index(&self, index: usize) -> &Self::Output {
        self.data[index].as_ref().unwrap()
    }
}

impl<T> IndexMut<usize> for Heap<T> {
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        self.data[index].as_mut().unwrap()
    }
}

impl<T> Stack<T> {
    pub fn new() -> Self {
        Stack(Vec::new())
    }

    pub fn push(&mut self, item: T) {
        self.0.push(item)
    }

    pub fn pop(&mut self) -> Option<T> {
        self.0.pop()
    }

    pub fn size(&self) -> usize {
        self.0.len()
    }
}

impl<T> Index<usize> for Stack<T> {
    type Output = T;

    fn index(&self, index: usize) -> &Self::Output {
        &self.0[index]
    }
}

// This trait is generated by ChatGPT
impl<'a, T> IntoIterator for &'a Stack<T> {
    type Item = &'a T;
    type IntoIter = std::slice::Iter<'a, T>;

    // This returns an iterator over references to the elements in the Stack
    fn into_iter(self) -> Self::IntoIter {
        self.0.iter() // Borrow the inner Vec<T> and return an iterator over references
    }
}

// This trait is generated by ChatGPT
impl<'a, T> IntoIterator for &'a Heap<T> {
    type Item = &'a Option<T>;
    type IntoIter = std::slice::Iter<'a, Option<T>>;

    // This returns an iterator over references to the elements in the Stack
    fn into_iter(self) -> Self::IntoIter {
        self.data.iter() // Borrow the inner Vec<T> and return an iterator over references
    }
}